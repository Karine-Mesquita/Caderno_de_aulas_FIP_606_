dplyr::pull()
aided
#faz um teste de variancia
var.test(unaided, aided)
hist(unaided)
hist(aided)
shapiro.test(unaided)
shapiro.test(aided)
#como a variancia foi heterogenea, faz o seguinte ajuste no teste
t.test(unaided, aided, paired = TRUE,
var.equal = FALSE)
#teste de Wilcoxon se apresenta como uma alterativa ao teste t pareado, ou seja, quando o objetivo também é verificar se existe diferença significativa de uma variável numérica entre dois grupos de interesse.
wilcox.test(unaided, aided)
#teste equivalente Mann-Whitney é o teste não paramétrico equivalente ao teste t para amostras independentes
wilcox.test(unaided, aided, paired = FALSE)
#paired = false o transforma num mann-whitney
micelial <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=959387827#gid=959387827")
#Análise visual
micelial |>
ggplot(aes(especie, tcm))+
geom_boxplot(outlier.colour = NA)+
geom_jitter(width = 0.1)
#Anova
anova1 <- aov(tcm ~ especie, data = micelial)
anova1
anova(anova1)
#outra forma de fazer a ANOVA
anova2 <- lm(tcm ~ especie, data = micelial)
anova(anova2)
#residuo é a diferença entre o estimado pelo modelo e o observado
#será que os resíduos são normais?
residuals(anova1) #resíduos da anova
hist(residuals(anova1))
shapiro.test(residuals(anova1)) #testa a normalidade dos resíduos
#teste para variancias de modelo
#teste bartlett testa se as variancias são homogeneas
bartlett.test(tcm ~ especie, data = micelial)
#teste de levene tem o mesmo propósito (menos sensível a desvios de normalidade
levene_test(tcm ~especie, data = micelial)
#Use Levene quando os dados não forem normalmente distribuídos.
#Use Bartlett quando os dados forem normalmente distribuídos.
#Se ambos os testes indicarem que as variâncias são iguais, você pode seguir com a ANOVA.
library(emmeans)
#pacote para calcular as médias do modelo e intervalo de confiança. Realiza contrastes e estimativas de médias após a modelagem estatística
m <- emmeans(anova2, ~ especie)
m
#emmeans nos deu a média por espécies, então usa o multicomp para comparar e visualizar as diferenças entre elas
#install.packages("multcomp")
#install.packages("multcompView")
library(multcomp)
library(multcompView)
#o pacote multcom realiza comparações múltiplas (post hoc) após modelos lineares, modelos lineares generalizados, e outros tipos de modelos
cld(m) #mostra letras compactas, ou seja, os grupos. Nesse caso, do emmeans
pwpm(m) #mostra as médias na diagonal e compara entre os tratamentos em forma de matriz
pairs(m) #mostra as médias em lista e compara, igual o anterior, mas com formas de saída diferentes. Mostra os resultados pareados
#no caso acima a  normalidade estava ok e as variancias eram nos resíduos
#aqui utilizamos um banco de dados do proprio R.
insetos <- InsectSprays
View(insetos) #comando para visualizar o conjunto de dados
insetos |>
ggplot(aes(spray, count))+
geom_boxplot(outlier.colour = NA)+
geom_jitter(width = 0.1)
#modelo de anova para inspecionar normalidade e variancia
anova3 <- lm(count ~spray, data = insetos)
anova(anova3)
#teste para variaveis homogeneas
bartlett.test(count ~spray, data = insetos)
#sempre que a variancia for heterogenea tem que ajustar
#Ajusta um modelo linear (lm) para verificar se o tipo de spray tem efeito no número de insetos mortos (count)
m2 <- lm(count ~spray, data = insetos)
hist(residuals (m2))
shapiro.test(residuals(m2))
#neste caso não é distribuição normal e nem homogenea
#verificar visualmente se os resíduos do modelo m2 seguem uma distribuição normal
qqnorm(residuals(m2))
qqline(residuals(m2))
#quando chamar qqnorm e qqline juntos a linha e os pontos tem que estar juntos, para ser de fato normal, indicar normalidade.
#primeiro testa função log
m3 <- lm(log(count + 0.1) ~spray, data = insetos)
hist(residuals (m3))
shapiro.test(residuals(m3))
qqnorm(residuals(m3))
qqline(residuals(m3))
#continuou com o erro, agora testa raiz quadrada
#REGRA: neste caso a raiz é uma boa saída pois quando são dados de contagem numa distribuição de poisson não normal, a raiz quadrada tende a normalizar a contagem individual.
#aplica o modelo raiz quadrada e aplica a Anova parametrica normal
m4 <- lm(sqrt(count) ~ spray, data = insetos)
hist(residuals (m4))
shapiro.test(residuals(m4))
qqnorm(residuals(m4))
qqline(residuals(m4))
#testar se as variâncias são homogêneas
bartlett.test(sqrt(count) ~spray, data = insetos)
anova(m4)
report(m4)
m44 <- emmeans(m4, ~spray, type = "response")
cld(m44)
plot(m44)
#ou seja ele não depende das duas premissas de normalidade e homogeneidade, ele faz um ranqueamento, tipo o wilcox
#O teste de Kruskal-Wallis é um método estatístico não paramétrico que compara se três ou mais grupos têm a mesma distribuição.
#mas este teste só diz que pelo menos um é diferente, mas não aponta quais são.
kruskal.test(count ~ spray, data = insetos)
kruskal_test(insetos, count ~ spray)
#Para realizar o teste de Kruskal-Wallis e fazer comparações múltiplas pós-hoc entre os grupos, semelhante ao Tukey, mas para dados não paramétricos.
library(agricolae)
kruskal.test(insetos$count, insetos$spray, group = TRUE, console = TRUE)
#Mostra o p valor e a diferença entre as médias. O "group = true" exibe as letras dos agrupamentos, enquanto "console = true" apresenta os resultados no console
#como foi significante, transforma para rank para fazer o não parametrico.
m5 <- lm(rank(count) ~spray, data = insetos)
m5
hist(residuals (m5))
shapiro.test(residuals(m5))
qqnorm(residuals(m5))
qqline(residuals(m5))
#quando partir para a alternativa a anova parametrica? ou seja, quando não possui normalidade nem homogeneidade dos dados.(usando shapiro-wilk, que testa normalidade dos residuos, e o bartlett ou levene que testam a homogeneidade)
#essas comparações multiplas são post-hoc, as duas primeiras opções, mas quando não dá siguinificativo não faz post hoc, pois não tem diferença entre grupos
#quando não tem via de transformação, nada resolveu o problema de normalidade e homocedasticidade, tem que usar não parametrico mesmo!
#utilizando o pacote DHARMa
#install.packages("DHARMa")
library(DHARMa)
#faz uma simulação dos residuos, não pega somente  observação
#o DHARMa é mais intuitivo, ao invés de usar Levene, hist, qqnorm, shapiro..., pode usar o teste DHARMa como padrão. Para ver visualmente todas estas estatisticas em uma única função, por meio da simulação dos resíduos. Dando siguinificativo, vai para os testes post hoc
library(emmeans)
library(tidyverse)
insetos <- InsectSprays
View(insetos)
m2 <- lm(count ~ spray, data = insetos) #variâncias não são homogêneas
plot(simulateResiduals(m2))
m2 <- lm(log(count+1) ~ spray, data = insetos) #transformar os dados para tornar as variâncias homogêneas
plot(simulateResiduals(m2))
library(emmeans) #para estimar as médias
library(multcomp)
m2.2 <- emmeans(m2, ~ spray, type = "response")
cld(m2.2)
#nas ANOVAs, possuem um tipos especial de modelo linear generalizado, onde a distribuição é normal, Gaussiana, existem familias de dirtrubuição.
#no caso de dados de contagem, como de insetos, usa de Poisson, neste caso não galsiana.
m2.3 <- glm(count ~ spray, data = insetos,
family = poisson)
m2.3
anova(m2.3)
plot(simulateResiduals(m2.3))
library(car)
Anova(m2.3)
medias_m2.3 <- emmeans(m2.3, ~ spray, type = "response")
medias_m4
cld(medias_m2.3)
#outra forma de testar o modelo
#install.packages("performance")
library(performance)
performance(m2.3)
check_model(m2.3)
#dados de sim e não, usa a familia binomial
#o professor recomenda usar o DHARMa ao invés do check model, ele não é tão consistente
m2.3 <- glm(count ~ spray, data = insetos,
family = poisson)
m2.3
anova(m2.3)
plot(simulateResiduals(m2.3))
library(car)
Anova(m2.3)
medias_m2.3 <- emmeans(m2.3, ~ spray, type = "response")
medias_m4
cld(medias_m2.3)
#outra forma de testar o modelo
#install.packages("performance")
library(performance)
performance(m2.3)
check_model(m2.3)
medias_m2.3 <- emmeans(m2.3, ~ spray, type = "response")
medias_2.3
fung_vaso <- read_xlsx("dados-diversos.xlsx", sheet = "fungicida_vaso")
library(gsheet)
fungicida_vaso <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=2023059672#gid=2023059672")
fungicida_vaso
fungicida_vaso
fungicida_vaso |>
ggplot(aes(factor(dose), severity*100))+
geom_jitter(width = 0.1)+
facet_wrap(~treat)
#Plotar o gráfico para análise visual dos dados
library(ggplot2)
fungicida_vaso |>
ggplot(aes(factor(dose), severity*100))+
geom_jitter(width = 0.1)+
facet_wrap(~treat)
m_anti <- lm(severity ~ treat*dose, data = fung_vaso)
m_anti <- lm(severity ~ treat*dose, data = fungicida_vaso)
anova(m_anti)
plot(simulateResiduals(m_anti))
#como deu siguinificativo as interações entre dose e tratamento, decompoe as médias dentro de cada tratamento e dose (trat x dose)
#testar se o modelo esta ok, usando o DHARMa
library(DHARMa)
plot(simulateResiduals(m_anti))
media_anti <- emmeans(m_anti, ~ treat |dose)
media_anti
cld(media_anti) #mostra as diferenças estatísticas
library(multcomp)
cld(media_anti) #mostra as diferenças estatísticas
#para letras das colunas (maiusculas)...
media_anti <- emmeans(m_anti, ~ treat |dose)
media_anti
cld(media_anti)
#...e linha (minusculas)
media_anti <- emmeans(m_anti, ~dose |treat)
media_anti
cld(media_anti)
#para o cv da tabela
library(agricolae)
cv.model(m_anti)
#caso não tivesse efeito, se fosse não siguinificativo, observar os efeitos simples
p1 <- fungicida_vaso |>
ggplot(aes(factor(dose),severity*100))+
geom_jitter(width =0.1)
p2 <- fungicida_vaso |>
ggplot(aes(factor(treat),severity*100))+
geom_jitter(width =0.1)
library(patchwork)
p1+p2
#função auxiliar para visualizar se a interação é siguinificativa ou não
interaction.plot(fungicida_vaso$treat, fungicida_vaso$dose, fungicida_vaso$severity, data = fungicida_vaso)
fungicida_vaso
#install.packages("epifitter")
library(epifitter)
oidio <- PowderyMildew
oidio <- PowderyMildew
oidio <- PowderyMildew
oidio
#install.packages("epifitter")
library(epifitter)
oidio <- PowderyMildew
oidio
oidio |>
ggplot(aes(time, sev))+
geom_point(width =0.1)+
facet_wrap(~irrigation_type)
oidio |>
filter(irrigation_type  %in% c("MS", "MS above canopy", "Overhead")) |> #filtrando as condições desejadas
ggplot(aes(time, sev*100))+
geom_jitter(width = 0.1)+
facet_grid(moisture ~ irrigation_type)
oidio |>
filter(irrigation_type  %in% c("MS", "MS above canopy", "Overhead")) |> #filtrando as condições desejadas
ggplot(aes(time, sev*100))+
geom_jitter(width = 0.1)+
facet_grid(moisture ~ irrigation_type)
oidio |>
ggplot(aes(time, sev))+
geom_point(width = 0.1)+
facet_wrap(~irrigation_type)
oidio |>
filter(irrigation_type  %in% c("MS", "MS above canopy", "Overhead")) |> #filtrando as condições desejadas
ggplot(aes(time, sev*100))+
geom_jitter(width = 0.1)+
facet_grid(moisture ~ irrigation_type)
mildio |>
ggplot(aes(time, sev))+
geom_point(width =0.1)+
facet_grid(irrigation_type ~moisture)
oidio |>
ggplot(aes(time, sev))+
geom_point(width =0.1)+
facet_grid(irrigation_type ~moisture)
oidio |>
filter(irrigation_type %in%c("MS", "MS above canopy", "Overhead")) |>
ggplot(aes(time, sev))+
geom_point()+
facet_grid(moisture ~irrigation_type)
oidio |>
filter(irrigation_type %in%c("MS", "MS above canopy", "Overhead")) |>
ggplot(aes(time, sev))+
geom_point()+
facet_grid(moisture ~ irrigation_type)
#install.packages("epifitter")
library(epifitter)
oidio <- PowderyMildew
oidio |>
filter(irrigation_type  %in% c("MS", "MS above canopy", "Overhead")) |> #filtrando as condições desejadas
ggplot(aes(time, sev*100))+
geom_jitter(width = 0.1)+
facet_grid(moisture ~ irrigation_type)
oidio |>
filter(~ irrigation_type  %in% c("MS", "MS above canopy", "Overhead")) |> #filtrando as condições desejadas
ggplot(aes(time, sev*100))+
geom_jitter(width = 0.1)+
facet_grid(moisture ~ irrigation_type)
oidio |>
filter(irrigation_type  %in% c("MS", "MS above canopy", "Overhead")) |> #filtrando as condições desejadas
ggplot(aes(time, sev*100))+
geom_jitter(width = 0.1)+
facet_grid(moisture ~ irrigation_type)
oidio3 <- oidio |>
group_by(irrigation_type, moisture, block) |>
summarize(AUDPC = AUDPC(time, sev))
oidio |>
filter(irrigation_type  %in% c("MS", "MS above canopy", "Overhead")) |> #filtrando as condições desejadas
ggplot(aes(time, sev*100))+
geom_jitter(width = 0.1)+
facet_grid(moisture ~ irrigation_type)
View(micelial)
View(oidio)
library(epifitter)
oidio <- PowderyMildew
oidio |>
filter(irrigation_type %in% c("MS", "MS above canopy", "Overhead")) |>
ggplot(aes(x = time, y = sev * 100)) +
geom_jitter(width = 0.1) +
facet_grid(moisture ~ irrigation_type)
# Verifique diretamente se a coluna existe
"irrigation_type" %in% names(oidio)
dados_filtrados <- oidio |>
filter(irrigation_type %in% c("MS", "MS above canopy", "Overhead"))
ggplot(dados_filtrados, aes(x = time, y = sev * 100)) +
geom_jitter(width = 0.1) +
facet_grid(moisture ~ irrigation_type)
#install.packages("epifitter")
library(epifitter)
oidio <- PowderyMildew
oidio
oidio |>
ggplot(aes(time, sev))+
geom_point(width = 0.1)+
facet_wrap(~irrigation_type)
oidio |>
filter(irrigation_type  %in% c("MS", "MS above canopy", "Overhead")) |> #filtrando as condições desejadas
ggplot(aes(time, sev*100))+
geom_jitter(width = 0.1)+
facet_grid(moisture ~ irrigation_type)
oidio |>
filter(irrigation_type %in% c("MS", "MS above canopy", "Overhead")) |>
mutate(
irrigation_type = factor(irrigation_type),
moisture = factor(moisture)
) |>
ggplot(aes(x = time, y = sev * 100)) +
geom_jitter(width = 0.1) +
facet_grid(moisture ~ irrigation_type)
library(dplyr)
oidio |>
filter(irrigation_type %in% c("MS", "MS above canopy", "Overhead")) |>
mutate(
irrigation_type = factor(irrigation_type),
moisture = factor(moisture)
) |>
ggplot(aes(x = time, y = sev * 100)) +
geom_jitter(width = 0.1) +
facet_grid(moisture ~ irrigation_type)
oidio |>
filter(irrigation_type  %in% c("MS", "MS above canopy", "Overhead")) |> #filtrando as condições desejadas
ggplot(aes(time, sev*100))+
geom_jitter(width = 0.1)+
facet_grid(moisture ~ irrigation_type)
oidio |>
filter(irrigation_type  %in% c("MS", "MS above canopy", "Overhead")) |> #filtrando as condições desejadas
ggplot(aes(time, sev*100))+
geom_jitter(width = 0.1)+
facet_grid(moisture ~ irrigation_type)
oidio |>
ggplot(aes(time, sev))+
geom_point(width =0.1)+
facet_grid(irrigation_type ~moisture)
oidio |>
filter(irrigation_type %in%c("MS", "MS above canopy", "Overhead")) |>
ggplot(aes(time, sev))+
geom_point()+
facet_grid(moisture ~ irrigation_type)
oidio |>
ggplot(aes(time, sev))+
geom_point(width =0.1)+
facet_grid(irrigation_type ~moisture)
oidio |>
filter(irrigation_type  %in% c("MS", "MS above canopy", "Overhead")) |> #filtrando as condições desejadas
ggplot(aes(time, sev*100))+
geom_jitter(width = 0.1)+
facet_grid(moisture ~ irrigation_type)
library(agricolae)
oidio1 |>
group_by(irrigation_type, moisture, block) |>
summarise(AUDPC = AUDPC(time, sev))
oidio |>
group_by(irrigation_type, moisture, block) |>
summarise(AUDPC = AUDPC(time, sev))
library(ggpubr)
oidio2 <- oidio |>
group_by(irrigation_type, moisture, block) |>
summarise(AUDPC = AUDPC(time, sev))
oidio2 <- oidio |>
group_by(irrigation_type, moisture, block) |>
summarise(AUDPC = AUDPC(time, sev))
oidio3 <- oidio |>
filter(irrigation_type %in% c("MS", "MS above canopy", "Overhead")) |>
group_by(irrigation_type, moisture, block) |>
summarise(AUDPC = AUDPC(time, sev))
oidio3 |>
ggplot(aes(irrigation_type,
AUDPC, color = moisture))+
geom_point(size = 2)+
facet_wrap(~moisture)+
scale_y_continuous(limits = c(0,20))
oidio3 <- oidio |>
filter(irrigation_type %in% c("MS", "MS above canopy", "Overhead")) |>
group_by(irrigation_type, moisture, block) |>
summarise(AUDPC = AUDPC(time, sev))
oidio3 |>
ggplot(aes(irrigation_type,
AUDPC, color = moisture))+
geom_point(size = 2)+
facet_wrap(~moisture)+
scale_y_continuous(limits = c(0,20))
oidio3 |>
filter(irrigation_type  %in% c("MS", "MS above canopy", "Overhead")) |>
ggplot(aes(irrigation_type, AUDPC, color = moisture))+
geom_point(width = 0.1)+
#facet_wrap(~ moisture)+
scale_y_continuous(limits = c(0,20))
oidio3 |>
filter(irrigation_type  %in% c("MS", "MS above canopy", "Overhead")) |>
ggplot(aes(irrigation_type, AUDPC, color = moisture))+
geom_point(width = 0.1)+
#facet_wrap(~ moisture)+
scale_y_continuous(limits = c(0,20))
oidio3 <- oidio |>
filter(irrigation_type %in% c("MS", "MS above canopy", "Overhead")) |>
group_by(irrigation_type, moisture, block) |>
summarise(AUDPC = AUDPC(time, sev))
oidio3 |>
ggplot(aes(irrigation_type,
AUDPC, color = moisture))+
geom_point(size = 2)+
facet_wrap(~moisture)+
scale_y_continuous(limits = c(0,20))
oidio3 |>
filter(irrigation_type  %in% c("MS", "MS above canopy", "Overhead")) |>
ggplot(aes(irrigation_type, AUDPC, color = moisture))+
geom_point(width = 0.1)+
#facet_wrap(~ moisture)+
scale_y_continuous(limits = c(0,20))
oidio3 |>
ggplot(aes(irrigation_type,
AUDPC, color = moisture))+
geom_point(size = 2)+
scale_y_continuous(limits = c(0,20))
oidio3 |>
ggplot(aes(irrigation_type,
AUDPC, color = moisture))+
geom_point(size = 2)+
facet_wrap(~moisture)+
scale_y_continuous(limits = c(0,20))
model_oidio <- lm(AUDPC ~ irrigation_type * moisture,
data = oidio3)
#Realizando a ANOVA fatorial
anov_oidio <- lm(sev ~ irrigation_type*moisture, data = oidio)
anova(anov_oidio)
#Realizando a ANOVA fatorial para AUDPC
oidio4 <- oidio3 |>
filter(irrigation_type  %in% c("MS", "MS above canopy", "Overhead"))
library(gsheet)
fungicida_vaso <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=2023059672#gid=2023059672")
fungicida_vaso
#Plotar o gráfico para análise visual dos dados
library(ggplot2)
fungicida_vaso |>
ggplot(aes(factor(dose), severity*100))+ #usamos factor para transformar dose em fator
geom_jitter(width = 0.1)+
facet_wrap(~treat)
#Testar se o efeito do tratamento depende da dose.
m_anti <- lm(severity ~ treat*dose, data = fungicida_vaso)
anova(m_anti)
library(DHARMa)
plot(simulateResiduals(m_anti))
#como não há problemas, pode seguir com o teste de comparação de médias
#comando para decompor as médias dos tratamentos dentro das doses.
media_anti <- emmeans(m_anti, ~ treat |dose)
media_anti #mostra as médias (no artigo, apresentar em tabela)
library(multcomp)
cld(media_anti) #mostrar as diferenças estatísticas para letras das colunas (maiusculas).
#decompões as médias de cada dose dentro dos tratamentos.
#mostrar as diferenças estatísticas para letras na linha (minusculas).
media_anti <- emmeans(m_anti, ~ dose |treat)
media_anti
cld(media_anti)
#para o CV (coeficiente de variação do modelo) da tabela
library(agricolae)
cv.model(m_anti)
#caso não tivesse inyteração, se fosse não siguinificativo, observar os efeitos simples
p1 <- fungicida_vaso |>
ggplot(aes(factor(dose),severity*100))+
geom_jitter(width =0.1)
p1
p2 <- fungicida_vaso |>
ggplot(aes(factor(treat),severity*100))+
geom_jitter(width =0.1)
p2
#Unindo os dois gráficos para comparação
library(patchwork)
p1+p2
#função auxiliar para visualizar se a interação é siguinificativa ou não
interaction.plot(fungicida_vaso$treat, fungicida_vaso$dose, fungicida_vaso$severity, data = fungicida_vaso)
#quando as linhas não são paralelas quer dizer que a interação é siguinificativa #quando são paralelas, interação não siguinificativa
```
#função auxiliar para visualizar se a interação é siguinificativa ou não
interaction.plot(fungicida_vaso$treat, fungicida_vaso$dose, fungicida_vaso$severity, data = fungicida_vaso)
#quando as linhas não são paralelas quer dizer que a interação é siguinificativa #quando são paralelas, interação não siguinificativa
```
#quando as linhas não são paralelas quer dizer que a interação é siguinificativa #quando são paralelas, interação não siguinificativa
```
#função auxiliar para visualizar se a interação é siguinificativa ou não
interaction.plot(fungicida_vaso$treat, fungicida_vaso$dose, fungicida_vaso$severity, data = fungicida_vaso)
p1+p2
#como não há problemas, pode seguir com o teste de comparação de médias
#comando para decompor as médias dos tratamentos dentro das doses.
library(emmeans)
