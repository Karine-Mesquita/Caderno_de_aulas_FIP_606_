---
title: "Aulas - FIP 606"
author: "Vinícius Fonsêca"
format: 
  pdf: default
  html: default
editor: visual
editor_options: 
  chunk_output_type: console
---

# Quarto

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

# Aula 1

Vamos importar um conjunto de dados que está disponível no R.

```{r}
dados <- Orange
dados

plot(dados$circumference)
```

```{r}
circ <- dados$circumference #Aqui estou criando o objeto "circ" a partir dos dados
circ

circ2 <- exp(circ) #Aqui estou criando o exponencial do objteto "circ" 
circ2

circ3 <- circ+10 #Aqui estou criando o circ+10 do objeto "circ"
circ3

#criando a coluna "logcirc" no meu conjunto de dados
dados$logcirc <- log(dados$circumference)
dados

#desagrega meu conjunto de dados e transforma cada coluna em variaveis independentes
attach(dados)
circumference

#agrega o conjunto de dados
detach(dados)
```

## Instalando e usando pacotes

```{r}
#install.packages("agricolae")
library(agricolae) #Usado em análises estatísticas aplicadas à agricultura
dates <- c(14,21,28)
dates

nomes <- c("Emerson", "Igor", "Diogo")
nomes

severity <- c(40,80,90)
severity

audpc(severity, dates) #área abaixo da curva de progresso da doença, do pacote agricolae
plot(dates,severity,type="h",ylim=c(0,100),col="red",axes=FALSE)

data(corn)
str(corn) #Vendo a estrutura dos dados
```

```{r}
#install.packages("tidyverse")
library(tidyverse) #Quando você instala e carrega o tidyverse você tem acesso a vários pacotes de uma vez
dates <- c(7,14,21,28,35,42)
severity <- c(0.1,5,10,35,50,60)

#Juntando datas e severidade em um objeto
data_curva <- data.frame(dates, severity)
data_curva
str(data_curva)

#Meu primeiro ggplot
data_curva |> 
  mutate (severity2 = c(1, 10, 35, 58, 70, 79)) |> #"mutate" modifica as variáveis dentro do conjunto de dados
  ggplot(aes(dates, severity2)) +
  #geom_area(fill = "yellow") +
  geom_line(linewidth = 1, color = "black") +
  geom_point(size = 3, color = "black") +
  theme_update() +
  labs (x = "Dias após plantio",
        y = "Severidade (%)") +
  scale_y_continuous(limits = c(0,100), n.breaks = 10)
```

# Aula 2

## Ler dados de arquivos

### Arquivo excel

```{r}
#install.packages("readxl")
library(tidyverse)
library(readxl) #Pacote para ler planilhas do excel

dados2 <- read_excel("dados-diversos.xlsx", sheet = "sensibilidade_fungicidas")
dados2
str(dados)
glimpse(dados2) #Dá uma visão rápida do objeto dados2, mostrando: o tipo de cada coluna (ex: número, texto, data), o nome das variáveis, e alguns valores de cada variável.

dados2 <- dados2 |> 
  mutate(dose = as.numeric(dose)) #Convertendo a variável "dose" em valores numéricos
dados2
```

### Arquivo .csv

```{r}
curve <- read_csv("dados-diversos.csv")
curve
View(curve)

library(writexl) #salva o arquivo do R em excel
write_xlsx(curve, "curva2.xlsx")
```

### Arquivo diretamente da nuvem

```{r}
#install.packages("gsheet")
library(gsheet) #Pacote para ler planilhas slvas na nuvem

dados_nuvem <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=983033137#gid=983033137")

survey <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=1118819738#gid=1118819738") #ao clicar em outra aba da planilha, muda-se o link, e esse pode ser selecionado

survey
survey |> 
  group_by(state, residue) |> 
  count()

RS <- survey |> 
  filter(state == "RS") #"filter" é usado para linhas, enquanto "select" é usado para colunas
View(RS)

PR <- survey |> 
  filter(state == "PR") 
View(PR)

combinado <- rbind(RS, PR) #juntando os dois conjuntos

survey_b  <- survey |> 
  dplyr::select(year, state, species) #Selecionando apenas algumas colunas da planilha
survey_b

survey_2009  <- survey |> 
  dplyr::select(year, state, species) |> 
  filter(year == 2009)

#install.packages("janitor")
library(janitor) #útil para trabalhar com tabelas de contigência

survey_b |> 
  tabyl(year, species) #monta a tabela de contigência

survey_b |> 
  group_by(year, species) |> 
  count() |> 
  ggplot(aes(year, n, fill = species, color = species))+
  geom_col()+
  #scale_fill_discrete()+
  scale_colour_viridis_d()
  #scale_fill_manual(values = c("red", "blue"))
  #facet_wrap(~year) #facetando por espécie
```

```{r}
#install.packages("ggthemes")
#install.packages("ggplot2")
library(ggthemes) #adiciona vários temas prontos e estilos de gráficos novos, além dos que já vêm no ggplot2
library(ggplot2)

mg <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=983033137#gid=983033137")
View(mg)
str(mg)

# Criar o gráfico
plot_mg <- ggplot(data = mg, aes(x = trat, y = comp)) +
  geom_boxplot(fill = "#e59500", outlier.colour = NA) +
  geom_jitter(width = 0.1, color = "gray20") +
  scale_y_continuous(limits = c(5, 20), n.breaks = 5) +
  labs(x = "Tratamentos", y = "Comprimento (mm)") +
  theme_minimal()

# Mostrar o gráfico
print(plot_mg)

plot_mg <- mg |> 
  ggplot(aes(trat, comp))+
  geom_boxplot(fill = "#e59500", #adiciona o boxplot
               outlier.colour = NA)+ #comando para adicionar transparência no outlier duplicado
  geom_jitter(width = 0.1, color = "gray20")+ #evita que os pontos fiquem sobrepostos
  scale_y_continuous(limits = c(5,20), n.breaks = 5)+ #mostrar pontos é preferível em relação à barras
  labs(x = "Tratamentos", 
       y = "Comprimento (mm)")+
       #title = "Efeito do magnésio",
       #subtitle = "Tamanho da lesão de mancha parda",
       #caption = "fonte (F. A. Rodrigues et al. 2020)")+
  theme_minimal()
  #theme_classic(base_size = 14)

ggsave("box.tiff", bg = "white", width = 5, height = 4) #também aceita em PNG
```

```{r}
micelial <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=959387827#gid=959387827")

plot_micelial <- micelial |> 
  ggplot(aes(reorder(especie, tcm), tcm))+
  geom_boxplot(outlier.colour = NA)+ 
  geom_jitter(width = 0.1, color = "gray20")+
  #scale_y_continuous(limits = c(0,2), n.breaks = 0.5)+ 
  #labs(x = "Tratamentos", 
   #    y = "tcm")+
  theme_grey()+ #Um fator com 5 níveis
  coord_flip()+ #invertendo as coordenadas
  labs(x = "",
       y = "Taxa de crescimento micelial (mm/dia)")

print(plot_micelial)
```

### Combinando dois gráficos

```{r}
#install.packages("patchwork")
library(patchwork)

#plot_mg + plot_micelial
#plot_mg / plot_micelial #plota um em cima do outro
(plot_mg | plot_micelial)+
  plot_annotation(tag_levels= "A")

ggsave("combo.tiff", bg = "white", width = 8, height = 4)
```

# Aula 3

```{r}
library(gsheet)
library(tidyverse)
dat_mg <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=983033137#gid=983033137")

dat_mg |> 
  ggplot(aes(trat, comp))+
  geom_jitter(width=0.1)

?t.test #mostra como esse comando funciona

dat_mg2 <- dat_mg |>
  pivot_wider (names_from = trat, values_from = comp) |> #Transformando o formato dos dados: O que era uma coluna "longa" vai virar várias colunas "largas".
  dplyr::select(-rep)

attach(dat_mg2)
t_results <- t.test(control, Mg2) #Teste T comparando os tratamentos.
t_results

#Explicando os resultados
#install.packages("report")
library(report) #Pacote para explicar os resultados das análises
report(t_results)
?report

#fazendo o teste T no formato longo
#install.packages("rstatix")
library(rstatix)
test <- t_test(comp ~ trat, data = dat_mg)
test

#Usando o pacote ggpubr para fazer o gráfico do teste t
#install.packages("ggpubr")
library(ggpubr)

p <- ggboxplot(
  dat_mg, x = "trat", y = "comp",
  color = "trat", palette = "jco")
print(p)

#add p-value manually
p + stat_pvalue_manual(test, label = "p",
  y.position = 18)+
    ylim(0,20)+
  labs(x = "Tratamento",
       y = "Comprimento (mm)")

ggsave("plot2.png", bg = "white")

#Testando a normalidade dos dados
shapiro.test(Mg2)
shapiro.test(control)

hist(Mg2)
hist(control)
var.test(dat_mg2$Mg2,
         dat_mg2$control) #testar a homogeneidade das variâncias
#quando as variancias não forem homogêneas, usa-se var.equal=false dentro dos parênteses
```

## Teste T para amostras dependentes

```{r}
escala <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=1729131173#gid=1729131173")

test <- t_test(acuracia ~ assessment,
       data = escala,
       paired = TRUE,
       var.equal = FALSE)
test

escala |> 
  ggplot(aes(assessment, acuracia))+
         geom_boxplot()

unaided <- escala |> 
  filter(assessment == "Unaided") |> 
  select(acuracia) |> 
  pull()
unaided

aided <- escala |> 
  filter(assessment == "Aided1") |> 
  select(acuracia) |> 
  pull()
aided

var.test(unaided, aided)

hist(unaided)
hist(aided)

shapiro.test(unaided)
shapiro.test(aided)

  t.test(unaided, aided, paired = TRUE,
         var.equal = FALSE)
  
wilcox.test(unaided, aided) #teste não paramétrico equivalente ao teste t pareado
wilcox.test(unaided, aided
            , paired = FALSE) #teste não paramétrico equivalente ao teste t, é chamado de Mann Whitney
```

## E quando há mais de três variáveis?

```{r}
library(readxl)
micelial <- read_xlsx("dados-diversos.xlsx", sheet = "micelial")
micelial |> 
  ggplot(aes(especie, tcm))+
         geom_boxplot(outlier.colour = NA)+
         geom_jitter()

anova1 <- aov(tcm ~ especie, data = micelial)
anova1
anova2 <- lm(tcm ~ especie, data = micelial) #apenas outra forma de fazer a ANOVA
anova2

anova(anova1)
anova(anova2)

residuals(anova1) #resíduos da anova
hist(residuals(anova1))
shapiro.test(residuals(anova1)) #testando a normalidade dos resíduos

bartlett.test(tcm ~ especie, data = micelial) #testa se as variâncias são homogêneas

levene_test(tcm ~ especie, data = micelial) #também testa se as variâncias são homogêneas

#install.packages("emmeans")
library(emmeans) #realiza contrastes e estimativas de médias após a modelagem estatística
m <- emmeans(anova2, ~ especie)
m

#install.packages("multcomp")
library(multcomp) #realiza comparações múltiplas (post hoc) após modelos lineares, modelos lineares generalizados, e outros tipos de modelos
#install.packages("multcompView")  #
library(multcompView)

cld(m) #mostra letras compactas, ou seja, os grupos. Nesse caso, do emmeans

pairs(m) #vê os resultados pareados
pwpm(m) #faz uma matriz dos resultados
```

## O que fazer quando os dados não seguem distribuição normal?

```{r}
insetos <- InsectSprays
View(insetos)

insetos |> 
  ggplot(aes(spray, count))+
  geom_boxplot(outlier.color = NA)+
  geom_jitter(width = 0.1)

m2 <- lm(count ~ spray, data = insetos) #Ajusta um modelo linear (lm) para verificar se o tipo de spray tem efeito no número de insetos mortos (count)

hist(residuals(m2))
shapiro.test(residuals(m2))

bartlett.test(count ~ spray, data = insetos)

qqnorm(residuals(m2)) #verifica visualmente se os resíduos do modelo m2 seguem uma distribuição normal
qqline(residuals(m2))
```

### Alternativa 1 - Transformação dos dados

```{r}
m3 <- lm(sqrt(count) ~ spray, data = insetos) #transformando os dados utilizando a raiz quadrada

shapiro.test(residuals(m3))
hist(residuals(m3))

qqnorm(residuals(m3))
qqline(residuals(m3))

bartlett.test(sqrt(count) ~ spray, data = insetos) #testa se as variâncias são homogêneas

anova(m3)
report(m3)

m33 <- emmeans(m3, ~ spray, type = "response") #destransforma os dados e dá a média original
plot(m33)
cld(m33)
```

### Alternativa 2 - Testes não paramétricos

```{r}
kruskal.test(count ~ spray, data = insetos)
kruskal_test(insetos, count ~ spray)

library(agricolae) #Realiza o teste de Kruskal-Wallis e faz comparações múltiplas pós-hoc entre os grupos, semelhante ao Tukey, mas para dados não paramétricos.
kruskal(insetos$count, insetos$spray, group = TRUE,
        console = TRUE) #Dá o p valor e a diferença entre as médias. O "group = true" exibe as letras dos agrupamentos, enquanto "console = true" apresenta os resultados no console
```

```{r}
#install.packages("DHARMa")
library(DHARMa)
library(tidyverse)

insetos <- InsectSprays
View(insetos)

m2 <- lm(count ~ spray, data = insetos) #aqui, as variâncias não são homogêneas
plot(simulateResiduals(m2))

m2 <- lm(log(count+1) ~ spray, data = insetos) #transformando os dados para tornar as variâncias homogêneas
plot(simulateResiduals(m2))

library(emmeans) #pacote para estimar as médias
library(multcomp)
m2.2 <- emmeans(m2, ~ spray, type = "response")
cld(m2.2)
```

### Terceira alternativa (paramétrica) - Modelos lineares generalizados (GLM's)

```{r}
m2.3 <- glm(count ~ spray, data = insetos,
          family = poisson) #o padrão do modelo é Gaussiano, aqui usamos Poisson por se tratar de dados de contagem
m2.3
anova(m2.3)

library(car)
Anova(m2.3)
plot(simulateResiduals(m2.3))

?glm

medias_m2.3 <- emmeans(m2.3, ~ spray, type = "response")
medias_m2.3
cld(medias_m2.3)
#No caso de contagens, a distribuição de poisson é recomendada

#install.packages("performance") #outra forma de testar o modelo
library(performance)
check_model(m2.3) #ajuda a decidir se o modelo está ok ou não
```

# Aula 4

## ANOVA fatorial (two-way ANOVA)

```{r}
library(readxl)
fung_vaso <- read_xlsx("dados-diversos.xlsx", sheet = "fungicida_vaso")

fung_vaso |> 
  ggplot(aes(factor(dose), severity*100))+ #transformando dose em um fator
  geom_jitter(width = 0.1)+
  facet_wrap(~ treat)

#Agora, o efeito do tratamento depende da dose? Vamos testar.

m_anti <- lm(severity ~ treat*dose, data = fung_vaso)
anova(m_anti)

#Desconsidera os efeitos simples e foca na interação

plot(simulateResiduals(m_anti))

media_anti <- emmeans(m_anti, ~ treat | dose) #decompões as médias de cada tratamento dentro das doses
media_anti #mostra as médias (que pode ser apresentada em tabela no artigo)

cld(media_anti) #mostra as diferenças estatísticas

#Repede tudo, só mudando a função. ATENÇÃO DEPOIS

media_anti <- emmeans(m_anti, ~ dose | treat) #decompões as médias de cada dose dentro dos tratamentos
media_anti #mostra as médias (que pode ser apresentada em tabela no artigo)

cld(media_anti) #mostra as diferenças estatísticas

cv.model(m_anti) #coeficiente de variação do modelo

#Supondo de não haja interação. Como seguir:
p1 <- fung_vaso |> 
  ggplot(aes(factor(dose), severity*100))+ 
  geom_jitter(width = 0.1)
p1

p2 <- fung_vaso |> 
  ggplot(aes(treat, severity*100))+ 
  geom_jitter(width = 0.1)
p2

library(patchwork)
p1 + p2

#Olhando se há interação visualmente

interaction.plot(fung_vaso$treat, fung_vaso$dose, fung_vaso$severity) #as linhas paralelas indicam não há interação (apenas visual, para análises prévias)
```

|          | 0.5     | 0.2    |
|----------|---------|--------|
| LI       | 29.2 Aa | 5.0 Ab |
| TEBU     | 2.1 Ba  | 2.0 Aa |
| cv = 63% |         |        |

```{r}
#install.packages("epifitter")
library(epifitter)
oidio <- PowderyMildew

oidio |> 
  filter(irrigation_type  %in% c("MS", "MS above canopy", "Overhead")) |> #filtrando as condições desejadas
  ggplot(aes(time, sev*100))+ 
  geom_jitter(width = 0.1)+
  facet_grid(moisture ~ irrigation_type) 

#Sumarizar a área abaixo da curva por tratamento e bloco

oidio3 <- oidio |> 
  group_by(irrigation_type, moisture, block) |> 
  summarize(AUDPC = AUDPC(time, sev))

oidio3 |> 
  filter(irrigation_type  %in% c("MS", "MS above canopy", "Overhead")) |>
  ggplot(aes(irrigation_type, AUDPC, color = moisture))+
  geom_point(width = 0.1)+
  #facet_wrap(~ moisture)+
  scale_y_continuous(limits = c(0,20))

#Realizando a ANOVA fatorial
##anov_oidio <- lm(sev ~ irrigation_type*moisture, data = oidio)
#anova(anov_oidio)

#Realizando a ANOVA fatorial para AUDPC
oidio4 <- oidio3 |> 
  filter(irrigation_type  %in% c("MS", "MS above canopy", "Overhead"))

anov_oidio <- lm(AUDPC ~ irrigation_type*moisture, data = oidio4)
anova(anov_oidio)

plot(simulateResiduals(anov_oidio))

medias_oidio <- emmeans(anov_oidio, ~ irrigation_type | moisture)
medias_oidio #mostra as médias
cld(medias_oidio) #compara as médias

medias_oidio2 <- emmeans(anov_oidio, ~ moisture | irrigation_type)
medias_oidio2 #mostra as médias
cld(medias_oidio2) #compara as médias

cv.model(anov_oidio)
```

|           | H. moisture | M. moisture |
|-----------|-------------|-------------|
| MS        | 8.52 Aa     | 11.18 Ab    |
| MS Ac.    | 3.99 Ba     | 4.86 Bb     |
| Overhead  | 3.68 Ba     | 3.81 Ca     |
| CV = 6.41 |             |             |

#Aula 5

```{r}
library(tidyverse)
library(readxl)
library(Hmisc)
fung_campo <- read_xlsx("dados-diversos.xlsx", sheet = "fungicida_campo")

fung_campo |> 
  mutate (TRAT = factor(TRAT)) |> 
  ggplot(aes(TRAT, PROD))+
  geom_jitter(width = 0.2)+
  stat_summary(
    fun.data = "mean_cl_boot", #dá a média dos dados no gráfico
    colour = "red", width = 0.3
  )

#Transformando tratamento e bloco em fator (porque estão em números, e o R reconhece como valores)
fung_campo$TRAT <- factor(fung_campo$TRAT)
fung_campo$BLOCO <- factor(fung_campo$BLOCO)

#realizando a ANOVA
anova_campo <-  lm(PROD ~ BLOCO + TRAT, data = fung_campo)
anova(anova_campo)

#Testando a normalidade e homocedasticidade
library(DHARMa)
plot(simulateResiduals(anova_campo))

means_campo <- emmeans(anova_campo, ~ TRAT)
means_campo

#Teste de médias
library(multcomp)
cld(means_campo)

plot(means_campo)

pwpp(means_campo)
pwpm(means_campo) #comparações na matriz

#Obs.: Nesse caso, não há diferença estatística, mesmo com grande ganho de produção nos tratamentos. Logo, é viável trabalhar com tamanho de efeito.

#Para ferrugem (severidade):

#realizando a ANOVA
anova_fer <-  lm(log(FER) ~ BLOCO + TRAT, data = fung_campo)
anova(anova_fer)

#Testando a normalidade e homocedasticidade
library(DHARMa)
plot(simulateResiduals(anova_fer))

means_fer <- emmeans(anova_fer, ~ TRAT, type = "response") #o "type = response" faz o emmeans entender que os valores foram transformados, mas que ele deve dar os valores reais no resultado.
means_fer

#Teste de médias
library(multcomp)
cld(means_fer)

plot(means_fer)

pwpp(means_fer)
pwpm(means_fer) #comparações na matriz

library(agricolae)
cv.model(anova_fer)
```

## Delineamento em parcelas subdivididas (split-plot)

```{r}
milho <- read_xlsx("dados-diversos.xlsx", sheet = "milho")

milho |> 
  ggplot(aes(hybrid, index, color = method))+
  geom_jitter(width = 0.1)+
  coord_flip()+
  facet_wrap(~ method)

install.packages("lme4") #para calcular modelos mistos
library(lme4)

milho$hybrid_block <- interaction(milho$hybrid, milho$block) #criando o indentificador da interação do híbrido com o bloco

milho |> 
  mutate(hybrid_block = interaction(hybrid, block)) #outra forma de criar a interação

#Criando o modelo (modelo misto)
m_milho <- lmer (index ~ hybrid*method + 
                   (1 | block:hybrid_block),
                 data = milho)
car::Anova(m_milho)
plot(simulateResiduals(m_milho))

library(emmeans)
media_milho <- emmeans(m_milho, ~ hybrid | method)
cld(media_milho, Letters = letters)

media_milho2 <- emmeans(m_milho, ~ method | hybrid)
cld(media_milho2, Letters = letters)

#Desconsiderando que é parcela subdividida (errado)
m_milho3 <- lm(index ~hybrid*method + block, data = milho)
plot(simulateResiduals(m_milho3))

#Fazendo agora para produtividade:
m_milho <- lmer (yield ~ hybrid*method + 
                   (1 | block:hybrid_block),
                 data = milho)
car::Anova(m_milho)
plot(simulateResiduals(m_milho))

media_milho <- emmeans(m_milho, ~ hybrid | method)
cld(media_milho, Letters = letters)

media_milho2 <- emmeans(m_milho, ~ method | hybrid)
cld(media_milho2, Letters = letters)

#Relação entre doença e produtividade

milho |> 
  ggplot(aes(index, yield))+
  geom_point()+
  geom_smooth(method = "lm") #cria linha de tendência no modelo linear

#Análise de correlação
cor.test(milho$index, milho$yield) #determinando o coeficiente de correlação
cor1 <- cor(milho$index, milho$yield) #outra opção
cor1*cor1*100 #calcula o coeficiente de determinação: quanto da variação de y está sendo explicado por x
```

```{r}
#As mesmas análises para o exemplo de campo
cor(fung_campo$FER, fung_campo$PROD)
cor.test(fung_campo$FER, fung_campo$PROD)

fung_campo |> 
  ggplot(aes(FER, PROD))+
  geom_point()+
  geom_smooth(method = "lm")

#Uma doença em função da outra
cor.test(fung_campo$FER, fung_campo$DFC)

fung_campo |> 
  ggplot(aes(FER, DFC))+
  geom_point()+
  geom_smooth(method = "lm")

#Na correlação temos duas respostas, e testamos a associação entre elas, que pode ser: sem associação, negativa ou positiva. Quando a associação é forte, a variabilidade é menor (o coeficiente de correlação varia de -1 a 1)
#R2 = 0.7 indica que 70% da variação de y é explicada por x

#Na análise de regressão usamos um fator quantitativo. Nesse caso, o x é uma variável independente (como dose), e no y uma variável dependente
```

#### O que são fatores fixos e aleatórios?

#### Estudar GLMs e modelos mistos

# Aula 6

#### Transformação dos dados

### Box Cox

## Alternativa mais direta nos dados originais (é uma potência)

```{r}
install.packages("MASS") 
library(MASS)
library(DHARMa) 
insects <- InsectSprays

m1 <- lm(count ~ spray, data = insects) 
m1 <- lm(sqrt(count) ~ spray, data = insects) 
m1 
plot(simulateResiduals(m1))

boxcox(lm(insects$count+0.1 ~1)) #os valores devem ser positivos, e há um valor de contagem igual a 0, por isso somo + 0.1
b <- boxcox(lm(insects$count+0.1 ~1))

lambda <- b$x[which.max(b$y)] 
lambda

library(tidyverse) 
insects <- insects |> 
  mutate(count2 = (count^lambda-1)/lambda) |> 
  mutate(count3 = (sqrt(count))) 
hist(insects$count2)
#usa o box cox quando testa logo, raiz ou outras transformações, mas não há forma de normalizar o modelo.
#Problema: no emmeans, ao colocar sqrt ou log para o tipo resposta no box cox, ele não retorna os valores destransformados. 
```

## Análise de regressão

```{r}
library(readxl)
estande <- read_xlsx("dados-diversos.xlsx", sheet = "estande")

#há efeito da porcentagem de inóculo na variável "número de plantas emergidas"?

library(ggplot2)
estande |> 
  ggplot(aes(trat, nplants))+
           geom_point()+
           geom_smooth(method = "lm", se = FALSE)+
           facet_wrap(~ exp)+
           theme_minimal()+
           labs(x = "% de inóculo na semente", y = "Número de plantas")
```

### Regressão

```{r}
#Fazendo um modelo para cada experimento
exp1 <- estande |> 
  filter(exp == 1) |> 
  #group_by(trat) |> 
  #summarise(nplants2 = mean(nplants))

#exp1 |> 
  #ggplot(aes(trat, nplants2))+
  #geom_point()+
  #ylim(20,60)

m_exp1 <- lm(nplants ~ trat, data = exp1)
summary(m_exp1)
#m_exp1 <- lm(nplants ~ trat + bloco, data = exp1)
#summary(m_exp1)

#no intercepto, a média de plantas é de 52 no estante, e a cada 1% de aumento do inóculo diminui em -0,24 o número de plantas no estande

exp2 <- estande |> 
  filter(exp == 2)

m_exp2 <- lm(nplants ~ trat, data = exp2)
summary(m_exp2)

#terceiro experimento

exp3 <- estande |> 
  filter(exp == 3)

m_exp3 <- lm(nplants ~ trat, data = exp3)
summary(m_exp3)

m_exp1$coefficients #calculando o slop para o experimento
m_exp2$coefficients
m_exp3$coefficients
```

## Modelo misto para inserir o experimento como efeito do experimento como modelo aleatório

```{r}
library(lme4)
m_misto <- lmer(nplants ~ trat + (1  | exp/bloco),
                data = estande) #tratamento é o efeito fixo, os experimentos e os blocos são efeitos aleatórios, e os blocos estão dentro dos experimentos
confint(m_misto)
summary(m_misto)

library(car)
car::Anova(m_misto)

#o p-valor foi significativo
```

```{r}
estande |> 
  ggplot(aes(trat, nplants, color = factor(exp)))+
  geom_point()+
  #geom_smooth(method = "lm", se = FALSE)+
  geom_abline(intercept = 69.74,
              slope = -0.56, linewidth = 2)+
  geom_abline(intercept = 43,
              slope = -0.73, linetype = "dashed")+
  geom_abline(intercept = 96,
              slope = -0.40, linetype = "dashed")
```

## Regressão não linear

```{r}
fungi <- read_xlsx("dados-diversos.xlsx", sheet = "sensibilidade_fungicidas")
fungi <- gsheet2tbl("https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=465348652#gid=465348652")

fungi |> 
  group_by(code, dose) |> 
  summarise(germination = mean(germination)) |> 
  ggplot(aes(dose, germination))+
  geom_point()+
  geom_line()+
  #geom_smooth(se = FALSE)+
  facet_wrap(~ code)

FGT43 <- fungi |> 
  group_by(code, dose) |> 
  summarise(germination = mean(germination)) |> 
  filter(code == "FGT43") #filtrando para o conjunto de médias de FGT43

install.packages("drc")
library(drc) #ajusta um modelo não linear aos dados

m43 <- drm(germination ~ dose,
           data = FGT43,
           fct = W2.3())

m43 <- drm(germination ~ dose,
           data = FGT43,
           fct = LL.3())
AIC(m43) #quanto menor o AIC, melhor o modelo
plot(m43)

summary(m43)
ED(m43, 50) #estima a EC50, ou seja, a dose que leva a 50% de germinação

#aqui eu testo para cada isolado, qual modelo fica melhor.

install.packages("ec50estimator")
library(ec50estimator) #um modelo só para todos os isolados

df_ec50 <- estimate_EC50(germination ~ dose,
                       data = fungi,
                       isolate_col = "code",
                       strata_col = "state",
                       interval = "delta", #padrão é EC50
                       fct = drc::LL.3()) #modelo LL.3

df_ec50 |> 
  ggplot(aes(reorder(ID, Estimate), Estimate))+ #reordena o ID pelo estimado (menor para maior)
  geom_point()+
  coord_flip()+
  labs(y = "EC50",
       x = "Isolados")

df_ec50 |> 
  ggplot(aes(x = Estimate))+
  geom_histogram(bins = 5, color = "white")

#sempre começa com o modelo LL.3
```
